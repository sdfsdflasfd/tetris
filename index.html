<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #0d0d1a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #e0e0ff;
      overflow: hidden;
    }
    #game-wrapper {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }
    canvas#board {
      display: block;
      border: 2px solid #3a3a5c;
      box-shadow: 0 0 30px rgba(100, 100, 255, 0.2);
    }
    #sidebar {
      width: 140px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .panel {
      background: #1a1a2e;
      border: 1px solid #3a3a5c;
      border-radius: 6px;
      padding: 10px 12px;
    }
    .panel h3 {
      font-size: 10px;
      color: #6060a0;
      letter-spacing: 2px;
      margin-bottom: 6px;
    }
    .panel .value {
      font-size: 20px;
      font-weight: bold;
      color: #e0e0ff;
    }
    canvas#preview {
      display: block;
      margin: 4px auto 0;
    }
    #controls-panel {
      font-size: 10px;
      color: #5050a0;
      line-height: 1.9;
    }
    #controls-panel span {
      color: #8080c0;
    }
  </style>
</head>
<body>
  <div id="game-wrapper">
    <canvas id="board"></canvas>
    <div id="sidebar">
      <div class="panel">
        <h3>NEXT</h3>
        <canvas id="preview"></canvas>
      </div>
      <div class="panel">
        <h3>SCORE</h3>
        <div class="value" id="score-display">0</div>
      </div>
      <div class="panel">
        <h3>LEVEL</h3>
        <div class="value" id="level-display">1</div>
      </div>
      <div class="panel">
        <h3>LINES</h3>
        <div class="value" id="lines-display">0</div>
      </div>
      <div class="panel" id="controls-panel">
        <span>← →</span> Move<br>
        <span>↑</span> Rotate CW<br>
        <span>Z</span> Rotate CCW<br>
        <span>↓</span> Soft Drop<br>
        <span>Space</span> Hard Drop<br>
        <span>P</span> Pause
      </div>
    </div>
  </div>

  <script>
    // ── Constants ─────────────────────────────────────────────────────────────
    const COLS = 10;
    const ROWS = 20;
    const CELL = 30;
    const LOCK_DELAY = 500;
    const MAX_LOCK_RESETS = 15;

    // ── Colors ────────────────────────────────────────────────────────────────
    const COLORS = [
      null,
      '#00f0f0', // 1 I - cyan
      '#f0f000', // 2 O - yellow
      '#a000f0', // 3 T - purple
      '#00f000', // 4 S - green
      '#f00000', // 5 Z - red
      '#0000f0', // 6 J - blue
      '#f0a000', // 7 L - orange
    ];

    // ── Tetromino shapes (all 4 rotations explicit) ───────────────────────────
    const TETROMINOES = {
      I: {
        color: 1,
        shapes: [
          [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
          [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],
          [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],
          [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
        ],
      },
      O: {
        color: 2,
        shapes: [
          [[1,1],[1,1]],
        ],
      },
      T: {
        color: 3,
        shapes: [
          [[0,1,0],[1,1,1],[0,0,0]],
          [[0,1,0],[0,1,1],[0,1,0]],
          [[0,0,0],[1,1,1],[0,1,0]],
          [[0,1,0],[1,1,0],[0,1,0]],
        ],
      },
      S: {
        color: 4,
        shapes: [
          [[0,1,1],[1,1,0],[0,0,0]],
          [[0,1,0],[0,1,1],[0,0,1]],
          [[0,0,0],[0,1,1],[1,1,0]],
          [[1,0,0],[1,1,0],[0,1,0]],
        ],
      },
      Z: {
        color: 5,
        shapes: [
          [[1,1,0],[0,1,1],[0,0,0]],
          [[0,0,1],[0,1,1],[0,1,0]],
          [[0,0,0],[1,1,0],[0,1,1]],
          [[0,1,0],[1,1,0],[1,0,0]],
        ],
      },
      J: {
        color: 6,
        shapes: [
          [[1,0,0],[1,1,1],[0,0,0]],
          [[0,1,1],[0,1,0],[0,1,0]],
          [[0,0,0],[1,1,1],[0,0,1]],
          [[0,1,0],[0,1,0],[1,1,0]],
        ],
      },
      L: {
        color: 7,
        shapes: [
          [[0,0,1],[1,1,1],[0,0,0]],
          [[0,1,0],[0,1,0],[0,1,1]],
          [[0,0,0],[1,1,1],[1,0,0]],
          [[1,1,0],[0,1,0],[0,1,0]],
        ],
      },
    };

    // ── SRS Wall Kick Tables ──────────────────────────────────────────────────
    // For JLSTZ pieces: offsets to try when rotation collides
    const SRS_KICKS_JLSTZ = {
      '0>>1': [[ 0,0],[-1,0],[-1,-1],[0, 2],[-1, 2]],
      '1>>0': [[ 0,0],[ 1,0],[ 1, 1],[0,-2],[ 1,-2]],
      '1>>2': [[ 0,0],[ 1,0],[ 1, 1],[0,-2],[ 1,-2]],
      '2>>1': [[ 0,0],[-1,0],[-1,-1],[0, 2],[-1, 2]],
      '2>>3': [[ 0,0],[ 1,0],[ 1,-1],[0, 2],[ 1, 2]],
      '3>>2': [[ 0,0],[-1,0],[-1, 1],[0,-2],[-1,-2]],
      '3>>0': [[ 0,0],[-1,0],[-1, 1],[0,-2],[-1,-2]],
      '0>>3': [[ 0,0],[ 1,0],[ 1,-1],[0, 2],[ 1, 2]],
    };

    // For I piece: different kick table
    const SRS_KICKS_I = {
      '0>>1': [[ 0,0],[-2,0],[ 1,0],[-2, 1],[ 1,-2]],
      '1>>0': [[ 0,0],[ 2,0],[-1,0],[ 2,-1],[-1, 2]],
      '1>>2': [[ 0,0],[-1,0],[ 2,0],[-1,-2],[ 2, 1]],
      '2>>1': [[ 0,0],[ 1,0],[-2,0],[ 1, 2],[-2,-1]],
      '2>>3': [[ 0,0],[ 2,0],[-1,0],[ 2,-1],[-1, 2]],
      '3>>2': [[ 0,0],[-2,0],[ 1,0],[-2, 1],[ 1,-2]],
      '3>>0': [[ 0,0],[ 1,0],[-2,0],[ 1, 2],[-2,-1]],
      '0>>3': [[ 0,0],[-1,0],[ 2,0],[-1,-2],[ 2, 1]],
    };

    // ── Canvas Setup ──────────────────────────────────────────────────────────
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const preview = document.getElementById('preview');
    const pCtx = preview.getContext('2d');

    const dpr = window.devicePixelRatio || 1;
    canvas.width = COLS * CELL * dpr;
    canvas.height = ROWS * CELL * dpr;
    canvas.style.width = COLS * CELL + 'px';
    canvas.style.height = ROWS * CELL + 'px';
    ctx.scale(dpr, dpr);

    const PREVIEW_CELL = 24;
    const PREVIEW_SIZE = 4 * PREVIEW_CELL;
    preview.width = PREVIEW_SIZE * dpr;
    preview.height = PREVIEW_SIZE * dpr;
    preview.style.width = PREVIEW_SIZE + 'px';
    preview.style.height = PREVIEW_SIZE + 'px';
    pCtx.scale(dpr, dpr);

    // ── Game State ────────────────────────────────────────────────────────────
    let board;
    let piece;
    let state;
    let rafId;

    function initState() {
      board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
      state = {
        score: 0,
        level: 1,
        lines: 0,
        gameOver: false,
        paused: false,
        nextType: null,
        bag: [],
        lockTimer: null,
        lockResets: 0,
        lastDrop: performance.now(),
        isLanding: false,
      };
      piece = null;
      refillBag();
      state.nextType = drawFromBag();
      spawnPiece();
      updateUI();
    }

    // ── Bag Randomizer ────────────────────────────────────────────────────────
    function refillBag() {
      const types = ['I','O','T','S','Z','J','L'];
      for (let i = types.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [types[i], types[j]] = [types[j], types[i]];
      }
      state.bag.push(...types);
    }

    function drawFromBag() {
      if (state.bag.length === 0) refillBag();
      return state.bag.shift();
    }

    // ── Spawn ─────────────────────────────────────────────────────────────────
    function spawnPiece() {
      const type = state.nextType;
      state.nextType = drawFromBag();
      const shape = TETROMINOES[type].shapes[0];
      const spawnX = Math.floor((COLS - shape[0].length) / 2);
      const spawnY = type === 'I' ? -1 : 0;

      piece = { type, rotation: 0, x: spawnX, y: spawnY };

      if (!isValid(piece.type, piece.rotation, piece.x, piece.y)) {
        state.gameOver = true;
      }

      state.isLanding = false;
      state.lockResets = 0;
      clearTimeout(state.lockTimer);
    }

    // ── Collision Detection ───────────────────────────────────────────────────
    function isValid(type, rotation, x, y) {
      const shape = TETROMINOES[type].shapes[rotation % TETROMINOES[type].shapes.length];
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const bx = x + c;
          const by = y + r;
          if (bx < 0 || bx >= COLS) return false;
          if (by >= ROWS) return false;
          if (by >= 0 && board[by][bx] !== 0) return false;
        }
      }
      return true;
    }

    // ── Ghost Piece ───────────────────────────────────────────────────────────
    function getGhostY() {
      let gy = piece.y;
      while (isValid(piece.type, piece.rotation, piece.x, gy + 1)) {
        gy++;
      }
      return gy;
    }

    // ── Movement ──────────────────────────────────────────────────────────────
    function tryMove(dx, dy) {
      if (!piece || state.gameOver || state.paused) return false;
      const nx = piece.x + dx;
      const ny = piece.y + dy;
      if (isValid(piece.type, piece.rotation, nx, ny)) {
        piece.x = nx;
        piece.y = ny;
        if (dy === 0 && state.isLanding) {
          // horizontal move while landing — reset lock timer
          resetLockTimer();
        }
        return true;
      }
      return false;
    }

    function softDrop() {
      if (!tryMove(0, 1)) {
        // already at bottom — trigger lock timer if not running
        startLockTimer();
      } else {
        state.score += 1;
        state.lastDrop = performance.now();
        updateUI();
      }
    }

    function hardDrop() {
      if (!piece || state.gameOver || state.paused) return;
      const ghostY = getGhostY();
      const dropped = ghostY - piece.y;
      piece.y = ghostY;
      state.score += dropped * 2;
      updateUI();
      lockPiece();
    }

    // ── Rotation ──────────────────────────────────────────────────────────────
    function rotatePiece(dir) {
      if (!piece || state.gameOver || state.paused) return;
      const numRotations = TETROMINOES[piece.type].shapes.length;
      const newRot = ((piece.rotation + dir) % numRotations + numRotations) % numRotations;
      const key = `${piece.rotation}>>${newRot}`;
      const kicks = piece.type === 'I' ? SRS_KICKS_I : SRS_KICKS_JLSTZ;
      const tests = kicks[key] || [[0, 0]];

      for (const [kdx, kdy] of tests) {
        const nx = piece.x + kdx;
        const ny = piece.y - kdy; // SRS uses inverted Y
        if (isValid(piece.type, newRot, nx, ny)) {
          piece.rotation = newRot;
          piece.x = nx;
          piece.y = ny;
          if (state.isLanding) resetLockTimer();
          return;
        }
      }
    }

    // ── Lock Delay ────────────────────────────────────────────────────────────
    function startLockTimer() {
      if (state.lockTimer !== null) return; // already running
      state.isLanding = true;
      state.lockTimer = setTimeout(lockPiece, LOCK_DELAY);
    }

    function resetLockTimer() {
      if (state.lockResets >= MAX_LOCK_RESETS) return;
      state.lockResets++;
      clearTimeout(state.lockTimer);
      state.lockTimer = setTimeout(lockPiece, LOCK_DELAY);
    }

    // ── Lock Piece ────────────────────────────────────────────────────────────
    function lockPiece() {
      if (!piece || state.gameOver) return;
      clearTimeout(state.lockTimer);
      state.lockTimer = null;
      state.isLanding = false;

      const shape = TETROMINOES[piece.type].shapes[piece.rotation % TETROMINOES[piece.type].shapes.length];
      const colorIdx = TETROMINOES[piece.type].color;

      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const by = piece.y + r;
          const bx = piece.x + c;
          if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) {
            board[by][bx] = colorIdx;
          }
        }
      }

      clearLines();
      spawnPiece();
      updateUI();
    }

    // ── Line Clear & Score ────────────────────────────────────────────────────
    const LINE_SCORES = [0, 100, 300, 500, 800];

    function clearLines() {
      let cleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          board.splice(r, 1);
          board.unshift(new Array(COLS).fill(0));
          cleared++;
          r++; // re-check same index after shift
        }
      }
      if (cleared > 0) {
        state.score += (LINE_SCORES[cleared] || 0) * state.level;
        state.lines += cleared;
        state.level = Math.floor(state.lines / 10) + 1;
      }
    }

    // ── Drop Interval ─────────────────────────────────────────────────────────
    function getDropInterval() {
      return Math.max(50, Math.pow(0.8 - (state.level - 1) * 0.007, state.level - 1) * 1000);
    }

    // ── UI Updates ────────────────────────────────────────────────────────────
    function updateUI() {
      document.getElementById('score-display').textContent = state.score;
      document.getElementById('level-display').textContent = state.level;
      document.getElementById('lines-display').textContent = state.lines;
    }

    // ── Rendering ─────────────────────────────────────────────────────────────
    function drawCell(context, cx, cy, colorIdx, cellSize, alpha) {
      if (!colorIdx) return;
      const color = COLORS[colorIdx];
      const x = cx * cellSize;
      const y = cy * cellSize;
      const s = cellSize - 1;

      context.globalAlpha = alpha !== undefined ? alpha : 1;
      context.fillStyle = color;
      context.fillRect(x + 0.5, y + 0.5, s - 1, s - 1);

      // Highlight (top-left bevel)
      context.fillStyle = 'rgba(255,255,255,0.25)';
      context.fillRect(x + 0.5, y + 0.5, s - 1, 3);
      context.fillRect(x + 0.5, y + 0.5, 3, s - 1);

      // Shadow (bottom-right bevel)
      context.fillStyle = 'rgba(0,0,0,0.3)';
      context.fillRect(x + 0.5, y + s - 3, s - 1, 3);
      context.fillRect(x + s - 3, y + 0.5, 3, s - 1);

      context.globalAlpha = 1;
    }

    function drawBoard() {
      // Background
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, COLS * CELL, ROWS * CELL);

      // Grid lines
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * CELL);
        ctx.lineTo(COLS * CELL, r * CELL);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * CELL, 0);
        ctx.lineTo(c * CELL, ROWS * CELL);
        ctx.stroke();
      }

      // Locked cells
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            drawCell(ctx, c, r, board[r][c], CELL, 1);
          }
        }
      }
    }

    function drawGhost() {
      if (!piece || state.gameOver) return;
      const gy = getGhostY();
      if (gy === piece.y) return; // no gap — don't draw
      const shape = TETROMINOES[piece.type].shapes[piece.rotation % TETROMINOES[piece.type].shapes.length];
      const colorIdx = TETROMINOES[piece.type].color;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const bx = piece.x + c;
          const by = gy + r;
          if (by >= 0 && by < ROWS) {
            drawCell(ctx, bx, by, colorIdx, CELL, 0.22);
          }
        }
      }
    }

    function drawActivePiece() {
      if (!piece || state.gameOver) return;
      const shape = TETROMINOES[piece.type].shapes[piece.rotation % TETROMINOES[piece.type].shapes.length];
      const colorIdx = TETROMINOES[piece.type].color;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          const bx = piece.x + c;
          const by = piece.y + r;
          if (by >= 0 && by < ROWS) {
            drawCell(ctx, bx, by, colorIdx, CELL, 1);
          }
        }
      }
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(0,0,0,0.72)';
      ctx.fillRect(0, 0, COLS * CELL, ROWS * CELL);

      ctx.fillStyle = '#ff4444';
      ctx.font = `bold ${CELL * 1.1}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('GAME OVER', COLS * CELL / 2, ROWS * CELL / 2 - CELL * 1.2);

      ctx.fillStyle = '#a0a0d0';
      ctx.font = `${CELL * 0.55}px 'Courier New', monospace`;
      ctx.fillText('Press ENTER to restart', COLS * CELL / 2, ROWS * CELL / 2 + CELL * 0.3);
    }

    function drawPause() {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, COLS * CELL, ROWS * CELL);

      ctx.fillStyle = '#e0e0ff';
      ctx.font = `bold ${CELL * 1.1}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSED', COLS * CELL / 2, ROWS * CELL / 2);
    }

    function drawPreview() {
      pCtx.fillStyle = '#1a1a2e';
      pCtx.fillRect(0, 0, PREVIEW_SIZE, PREVIEW_SIZE);

      if (!state.nextType) return;
      const shape = TETROMINOES[state.nextType].shapes[0];
      const colorIdx = TETROMINOES[state.nextType].color;
      const rows = shape.length;
      const cols = shape[0].length;
      const offsetX = Math.floor((4 - cols) / 2);
      const offsetY = Math.floor((4 - rows) / 2);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (shape[r][c]) {
            drawCell(pCtx, c + offsetX, r + offsetY, colorIdx, PREVIEW_CELL, 1);
          }
        }
      }
    }

    function render() {
      drawBoard();
      drawGhost();
      drawActivePiece();
      drawPreview();
      if (state.paused) drawPause();
      if (state.gameOver) drawGameOver();
    }

    // ── Game Loop ─────────────────────────────────────────────────────────────
    function loop(timestamp) {
      if (!state.gameOver && !state.paused) {
        const delta = timestamp - state.lastDrop;
        if (delta >= getDropInterval()) {
          // Gravity tick
          if (!tryMove(0, 1)) {
            startLockTimer();
          }
          state.lastDrop = timestamp;
        }
      }
      render();
      rafId = requestAnimationFrame(loop);
    }

    // ── Keyboard Input ────────────────────────────────────────────────────────
    document.addEventListener('keydown', (e) => {
      if (state.gameOver) {
        if (e.key === 'Enter') {
          initState();
        }
        e.preventDefault();
        return;
      }

      if (e.key === 'p' || e.key === 'P') {
        togglePause();
        e.preventDefault();
        return;
      }

      if (state.paused) {
        e.preventDefault();
        return;
      }

      switch (e.key) {
        case 'ArrowLeft':  tryMove(-1, 0); break;
        case 'ArrowRight': tryMove(1, 0);  break;
        case 'ArrowDown':  softDrop();     break;
        case 'ArrowUp':    rotatePiece(1); break;
        case 'x': case 'X': rotatePiece(1); break;
        case 'z': case 'Z': rotatePiece(-1); break;
        case ' ':           hardDrop();    break;
        default: return; // don't prevent default for unrecognized keys
      }
      e.preventDefault();
    });

    // ── Pause ─────────────────────────────────────────────────────────────────
    function togglePause() {
      state.paused = !state.paused;
      if (!state.paused) {
        // Reset drop clock to avoid gravity debt
        state.lastDrop = performance.now();
      }
    }

    // ── Start ─────────────────────────────────────────────────────────────────
    initState();
    rafId = requestAnimationFrame(loop);
  </script>
</body>
</html>
